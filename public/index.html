<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Boggle Solver</title>

    <!-- Use bootstrap css and js for easy, pretty prototyping -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css">
    <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>

    <!-- bootstrap apparently by default now targets the slim build of jquery
    <!--<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script>-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js"></script>

    <!-- stylesheets -->
    <link rel="stylesheet" href="./boggle.css">

    <!-- boggle code -->
    <!--
      Note that we're keeping everything simple and in one file to focus on the the product and 
      speed of development and this is not indicative of a production architecture. Pretty much
      anywhere that I could cut a corner to save time without sacrificing the algorithm or usability
      of the product that I could, I did so that I could funnel that time into the focus of the project.

      I'm purposefully not setting up node or webpack or react and just using bootstrap and jquery to
      build something barebones but functional as quickly as possible to be mindful of the time limit.
      
      ...but I'm definitely missing babel right now! :P
    -->

    <script type="text/javascript">
      // GLOBAL

      // The boggle board will just be a 2D array. We could use a flat array and modulo to find neighbors and
      // scale to bigger boards quicker but this helps to visualize in a smaller project at the moment, easy
      // future enhancement here.
      var boggle = null;

      // Similar to above, we're just going to use a keyed javascript object to create a tree here instead of
      // a defined type that is more memory conscientious as this helps introspection easier in the early stages.
      var tree = {word: false};

      // accumulate answers here to simplify functional interfaces for a prototype
      var answers = [];

      // CONSTANTS
      var END_OF_WORD = '$';

      // For each letter in the word:
      //   - Check if it's in the tree at this position
      //   - Add it to the tree if it's not already there
      //   - Set the value of that key in the dictionary to true if it's the terminus of the word
      //   - Call add_word_to_tree for the next letter
      function add_word_to_tree(node, word) {
        if (!word || !word.length || word.length < 1) {
          console.log('error: called add_word_to_tree with bad input: ', word);
          return;
        }

        if (word != null) {
          var letter = word[0];
          if (!(letter in node)) {
            node[letter] = {word: (word.length == 1)};
          } else {
            node[letter].word = node[letter].word || word.length == 1;
          }

          if (word.length > 1) {
            add_word_to_tree(node[letter], word.slice(1, word.length));
          }
        }
      }

      // Build a tree of words letter by letter that will let us easily
      // traverse it and quickly find boggle solutions
      function add_words_to_tree(event) {
        var words = event.detail;
        for (var i = 0; i < words.length; i++) {
          if (!!words[i] && words[i].length > 0) {
            add_word_to_tree(tree, words[i]);
          }
        }

        $('#solve_button').disabled = false;
      }

      function load_dict() {
//        $.get("./pen_dict.txt", function(data, status) {
        $.get("./boggle_dict.txt", function(data, status) {
          var words = data.split('\n');
          var event = new CustomEvent('dictionary_loaded', {detail: words});
          document.dispatchEvent(event);
        });
      }

      function init_tree() {
        // doing some oldschool event handling to free memory quicker as this simple prototype is a bit of a memory hog
        document.addEventListener('dictionary_loaded', add_words_to_tree, false);
        load_dict();
      }

      // get all of the neighbors that haven't been hit yet
      function get_untraversed_neighbors(x, y, traversed) {
        var neighbors = [];
        for (var i = x - 1; i <= x + 1; i++) {
          for (var j = y - 1; j <= y + 1; j++) {
            if (!(i == x && j == y) && 
                i >= 0 && i < traversed.length &&
                j >= 0 && j < traversed[i].length &&
                traversed[i][j] == false) {
              neighbors.push({x: i, y: j});
            }
          }
        }

        return neighbors;
      }

      function boggle_recurse(subtree, traversed, string_accum, next_letter) {
        var x = next_letter.x;
        var y = next_letter.y;
        var letter = boggle[x][y];

        // If we called this function and have already hit this node...something went wrong
        if (traversed[x][y]) {
          console.log('ALREADY TRAVERSED - stopping');
          return;
        }

        // is the letter we're checking in the tree
        if (letter in subtree) {
          // deep clone the array because js passes arrays by reference, this
          // is another shortcoming of using this approach and normally i'd refactor this
          // at this point if there were more time. FIXME
          var new_traversed = jQuery.extend(true, [], traversed);

          // mark that we've hit this letter in the grid
          new_traversed[x][y] = true;

          // if so, add it to our string and save an answer if it's a valid word
          string_accum += letter;
          if (subtree[letter].word) {
            answers.push(string_accum);
          }
          
          // check all of our untraversed neighbors
          var untraversed = get_untraversed_neighbors(x, y, new_traversed);
          for (var i = 0; i < untraversed.length; i++) {
            var neighbor = untraversed[i];
            boggle_recurse(subtree[letter], new_traversed, string_accum, {x: neighbor.x, y: neighbor.y}, []);
          }

        }
      }

      // we're going to use a 2D array the size of the boggle board
      // to denote which nodes we've hit already. This isn't pretty but it's fast
      // and helps to visualize what's going on at this stage
      function get_new_traversal_array() {
        return [
          [false, false, false, false],
          [false, false, false, false],
          [false, false, false, false],
          [false, false, false, false]
        ];
      }

      function solve_boggle() {
        for (var i = 0; i < boggle.length; i++) {
          for (var j = 0; j < boggle[i].length; j++) {
            var traversed = get_new_traversal_array();
            boggle_recurse(tree, traversed, '', {x: i, y: j});
          }
        }
      }

      init_tree();
    </script>

  </head>
  <body>
    <h1>Boggle Solver<h1>
    <div id="intro">
      <h2>Welcome</h2>
      <p>This is a solver for boggle, enter your puzzle below and click solve!<p>
    </div>

    <div class="boggle-grid">
      <div class="row">
        <input class="boggle-letter" maxlength="1" type="text" id="00">
        <input class="boggle-letter" maxlength="1" type="text" id="01">
        <input class="boggle-letter" maxlength="1" type="text" id="02">
        <input class="boggle-letter" maxlength="1" type="text" id="03">
      </div>
      <div class="row">
        <input class="boggle-letter" maxlength="1" type="text" id="10">
        <input class="boggle-letter" maxlength="1" type="text" id="11">
        <input class="boggle-letter" maxlength="1" type="text" id="12">
        <input class="boggle-letter" maxlength="1" type="text" id="13">
      </div>
      <div class="row">
        <input class="boggle-letter" maxlength="1" type="text" id="20">
        <input class="boggle-letter" maxlength="1" type="text" id="21">
        <input class="boggle-letter" maxlength="1" type="text" id="22">
        <input class="boggle-letter" maxlength="1" type="text" id="23">
      </div>
      <div class="row">
        <input class="boggle-letter" maxlength="1" type="text" id="30">
        <input class="boggle-letter" maxlength="1" type="text" id="31">
        <input class="boggle-letter" maxlength="1" type="text" id="32">
        <input class="boggle-letter" maxlength="1" type="text" id="33">
      </div>
      <div class="row">
        <button id="solve-button" disabled="true" type="button" class="btn btn-outline-info boggle-button">Solve</button>
        <button id="reset-button" type="button" class="btn btn-outline-danger boggle-button">Reset</button>
      </div>
    </div>
  </body>
</html>
